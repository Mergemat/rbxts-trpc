---
title: Create Your First Router
description: Model your game API with procedures and events.
---

This guide sets up a small `todos` contract with both RPC calls and events.

## Define context

```ts
import { initTRPC } from "rbxts-trpc";

interface GameContext {
	player?: Player;
	requestId: string;
}

const trpc = initTRPC()
	.context<GameContext>()
	.create({
		createContext: ({ player, path }) => ({
			player,
			requestId: `req:${path}`,
		}),
	});
```

## Build a router tree

```ts
import { t } from "@rbxts/t";

const todoName = t.string;
const todoList = t.array(todoName);

export const appRouter = trpc.router({
	todos: trpc.router({
		getAll: trpc.procedure
			.intent("query")
			.output<string[]>(todoList)
			.resolve(() => ["Milk", "Eggs"]),

		add: trpc.procedure
			.input<string>(todoName)
			.output<string[]>(todoList)
			.resolve(({ input }) => ["Milk", "Eggs", input]),

		addViaEvent: trpc.event.server.input<string>(todoName).handle(({ input }) => {
			print(`event add ${input}`);
		}),

		changed: trpc.event.client.input<string[]>(todoList).create(),
	}),
});
```

## What `.intent(...)` does

`intent` marks how a procedure is used:

- `.intent("query")`: read-style call (fetches state)
- `.intent("mutation")`: write-style call (changes state)

If you do not set it, the default is `"mutation"`.

```ts
const getProfile = trpc.procedure
	.intent("query")
	.output<Profile>(profileValidator)
	.resolve(({ ctx }) => loadProfile(ctx.player));

const updateProfile = trpc.procedure
	.intent("mutation")
	.input<ProfilePatch>(profilePatchValidator)
	.resolve(({ input, ctx }) => saveProfile(ctx.player, input));
```

Use `query` for reads so client-side query helpers map naturally to your API.

## Why mix procedures and events?

- Procedures are request/response and easier to reason about
- Events are push-based and better for fan-out updates
- Keeping both in one contract avoids type drift

## Recommended pattern

Use this split for most games:

- **Procedures:** authoritative reads/writes
- **Server events:** user intents that do not need response payloads
- **Client events:** broadcasts and invalidation signals
